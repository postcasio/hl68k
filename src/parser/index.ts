/* parser generated by jison 0.3.0 */
/**
 * Returns a Parser implementing JisonParserApi and a Lexer implementing JisonLexerApi.
 */

  import { OperandSize, getOperandSize } from '../arch/68k/instructions'

  function hexlify (str: string): string {
    return str.split('').map(ch => '0x' + ch.charCodeAt(0).toString(16)).join(', ')
  }

  function parseNumber(num: string): number {
    num = num.replace('_', '');

    if (num.substr(0, 2) === '0b') {
      return parseInt(num.substr(2), 2);
    }

    if (num.substr(0, 1) === '$') {
      return parseInt(num.substr(1), 16);
    }

    return parseInt(num, 10);
  }

  function parseString(str: string) {
    return JSON.parse(str.replace('\\0', '\\u0000'));
  }

  export interface ASTBlockNode {
    type: NodeType.Block;
    path: string;
    name: string;
    properties: ASTPropertyNode[];
    code: ASTBlockLevelNode[];
  }

  export type ASTBlockLevelNode = ASTStatementNode | ASTLabelNode;

  export interface ASTStatementNode {
    type: NodeType.Statement;
    path: string;
    instruction: ASTInstructionNode;
  }

  export interface ASTInstructionNode {
    type: NodeType.Instruction;
    path: string;
    mnemonic: string;
    size: OperandSize;
    arguments: ASTExpressionNode[];
  }

  export interface ASTPropertyNode {
    type: NodeType.Property;
    path: string;
    name: string;
    value: ASTExpressionNode;
  }

  export interface ASTUnitNode {
    type: NodeType.Unit;
    path: string;
    code: ASTTopLevelBlockNode[];
  }

  export interface ASTIncludeNode {
    type: NodeType.Include;
    path: string;
    file: ASTStringNode;
  }

  export interface ASTStringNode {
    type: NodeType.String;
    path: string;
    value: string;
  }

  export interface ASTBankNode {
    type: NodeType.Bank;
    path: string;
    name: string;
    properties: ASTPropertyNode[];
  }

  export interface ASTAssignmentNode {
    type: NodeType.Assignment;
    path: string;
    name: string;
    value: ASTExpressionNode;
  }

  export interface ASTRegisterListNode {
    type: NodeType.RegisterList;
    path: string;
    registers: (ASTIdentifierNode | ASTRegisterRangeNode)[];
  }

  export interface ASTRegisterRangeNode {
    type: NodeType.RegisterRange;
    path: string;
    start: ASTIdentifierNode;
    end: ASTIdentifierNode;
  }

  export type ASTTopLevelBlockNode = ASTBlockNode | ASTBankNode | ASTAssignmentNode | ASTIncludeNode | ASTMacroNode;

  export type ASTExpressionNode = ASTIndirectNode | ASTAbsoluteNode | ASTNumberNode | ASTAdditionNode | ASTSubtractionNode | ASTMultiplicationNode | ASTDivisionNode | ASTIdentifierNode | ASTUnaryMinusNode | ASTImmediateNode | ASTStringNode | ASTRegisterListNode | ASTRegisterRangeNode | ASTLeftShiftNode | ASTRightShiftNode | ASTBitwiseOrNode | ASTBitwiseAndNode;

  export interface ASTAbsoluteNode {
    type: NodeType.Absolute;
    path: string;
    value: ASTExpressionNode;
    size: OperandSize;
  }

  export interface ASTIndirectNode {
    type: NodeType.Indirect;
    path: string;
    value: ASTExpressionNode;
    predecrement?: boolean;
    postincrement?: boolean;
    displacement?: ASTExpressionNode;
    index?: ASTExpressionNode;
    indexSize?: OperandSize;
  }

  export interface ASTNumberNode {
    type: NodeType.Number;
    path: string;
    value: number;
  }

  export interface ASTAdditionNode {
    type: NodeType.Addition;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTSubtractionNode {
    type: NodeType.Subtraction;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTLeftShiftNode {
    type: NodeType.LeftShift;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTRightShiftNode {
    type: NodeType.RightShift;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTBitwiseOrNode {
    type: NodeType.BitwiseOr;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTBitwiseAndNode {
    type: NodeType.BitwiseAnd;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTMultiplicationNode {
    type: NodeType.Multiplication;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTDivisionNode {
    type: NodeType.Division;
    path: string;
    left: ASTExpressionNode;
    right: ASTExpressionNode;
  }

  export interface ASTIdentifierNode {
    type: NodeType.Identifier;
    path: string;
    identifier: string;
  }

  export interface ASTUnaryMinusNode {
    type: NodeType.UnaryMinus;
    path: string;
    value: ASTExpressionNode;
  }

  export interface ASTLabelNode {
    type: NodeType.Label;
    path: string;
    name: string;
  }


  export interface ASTImmediateNode {
    type: NodeType.Immediate;
    path?: string;
    value: ASTExpressionNode;
  }

  export interface ASTMacroNode {
    type: NodeType.Macro;
    path: string;
    name: string;
    arguments: string[];
    code: ASTBlockLevelNode[];
  }

  export type ASTNode = ASTExpressionNode | ASTBlockLevelNode | ASTTopLevelBlockNode | ASTInstructionNode;


  export enum NodeType {
    Block = 'BLOCK',
    Property = 'PROPERTY',
    Identifier = 'IDENTIFIER',
    Number = 'NUMBER',
    Unit = 'UNIT',
    Statement = 'STATEMENT',
    Instruction = 'INSTRUCTION',
    Label = 'LABEL',
    Immediate = 'IMMEDIATE',
    Indirect = 'INDIRECT',
    Addition = 'ADDITION',
    Subtraction = 'SUBTRACTION',
    UnaryMinus = 'UNARY_MINUS',
    Bank = 'BANK',
    Multiplication = 'MULTIPLICATION',
    Division = 'DIVISION',
    Assignment = 'ASSIGNMENT',
    Include = 'INCLUDE',
    String = 'STRING',
    Absolute = 'ABSOLUTE',
    RegisterList = 'REGISTER_LIST',
    RegisterRange = 'REGISTER_RANGE',
    Macro = 'MACRO',
    RightShift = 'RIGHT_SHIFT',
    LeftShift = 'LEFT_SHIFT',
    BitwiseOr = 'BITWISE_OR',
    BitwiseAnd = 'BITWISE_AND'
  }

import { JisonParser, JisonParserApi, StateType, SymbolsType, TerminalsType, ProductionsType, o } from '@ts-jison/parser';const $V0=[1,11],$V1=[1,12],$V2=[1,13],$V3=[1,14],$V4=[1,15],$V5=[1,4],$V6=[1,17],$V7=[6,13,15,18,23,26,28,35,66],$V8=[6,13,15,18,23,28],$V9=[1,21],$Va=[21,33,66],$Vb=[1,38],$Vc=[1,37],$Vd=[1,32],$Ve=[1,39],$Vf=[1,44],$Vg=[21,33,57,59,60,61,66],$Vh=[1,52],$Vi=[1,51],$Vj=[21,33,42,50,57,59,60,61,66],$Vk=[1,55],$Vl=[1,54],$Vm=[21,33,40,42,50,57,59,60,61,63,66],$Vn=[1,61],$Vo=[21,33],$Vp=[1,77],$Vq=[2,75],$Vr=[1,99],$Vs=[26,35],$Vt=[15,26],$Vu=[1,117],$Vv=[1,121],$Vw=[1,118],$Vx=[1,116],$Vy=[2,36],$Vz=[33,66],$VA=[33,40,66],$VB=[1,142],$VC=[1,143];

export class HL68kParser extends JisonParser implements JisonParserApi {
    $?: any;

    constructor (yy = {}, lexer = new HL68kLexer(yy)) {
      super(yy, lexer);
    }

    symbols_: SymbolsType = {"error":2,"unit":3,"newline":4,"definition_list":5,"EOF":6,"definition":7,"include":8,"assignment":9,"macro":10,"block":11,"bank":12,"INCLUDE":13,"string":14,"IDENTIFIER":15,"=":16,"math":17,"MACRO":18,"(":19,"macro_argument_list":20,")":21,"block_body":22,"BLOCK":23,"property_list":24,"{":25,"}":26,"stmt_list":27,"BANK":28,"property_stmt_list":29,"stmt":30,"instruction":31,"label":32,",":33,"property":34,"PROPERTY":35,"property_expr":36,"register":37,"REGISTER":38,"register_list":39,"/":40,"register_list_expr":41,"-":42,"arguments":43,"expr":44,":":45,"index_size":46,".w":47,".l":48,"indirect":49,"+":50,"number":51,"NUMBER":52,"immediate":53,"identifier":54,"#":55,"bitwise":56,"<<":57,"complex":58,">>":59,"|":60,"&":61,"term":62,"*":63,"factor":64,"STRING":65,"NEWLINE":66,"$accept":0,"$end":1};
    terminals_: TerminalsType = {2:"error",6:"EOF",13:"INCLUDE",15:"IDENTIFIER",16:"=",18:"MACRO",19:"(",21:")",23:"BLOCK",25:"{",26:"}",28:"BANK",33:",",35:"PROPERTY",38:"REGISTER",40:"/",42:"-",45:":",47:".w",48:".l",50:"+",52:"NUMBER",55:"#",57:"<<",59:">>",60:"|",61:"&",63:"*",65:"STRING",66:"NEWLINE"};
    productions_: ProductionsType = [0,[3,3],[3,2],[5,2],[5,1],[7,1],[7,1],[7,1],[7,1],[7,1],[8,3],[9,4],[10,7],[11,7],[11,6],[22,3],[22,4],[12,7],[27,2],[27,1],[30,2],[30,3],[30,2],[20,3],[20,1],[24,3],[24,1],[29,3],[29,2],[34,3],[37,1],[39,3],[39,1],[41,3],[41,1],[31,2],[31,1],[43,3],[43,1],[32,2],[46,1],[46,1],[49,3],[49,4],[49,4],[49,4],[49,5],[49,8],[49,6],[51,1],[44,1],[44,1],[44,1],[44,1],[44,1],[36,1],[36,1],[54,1],[53,2],[53,2],[17,1],[56,3],[56,3],[56,3],[56,3],[56,1],[58,3],[58,3],[58,2],[58,1],[62,3],[62,3],[62,1],[64,1],[64,1],[64,3],[14,1],[4,2],[4,1]];
    table: Array<StateType> = [{3:1,4:2,5:3,7:5,8:6,9:7,10:8,11:9,12:10,13:$V0,15:$V1,18:$V2,23:$V3,28:$V4,66:$V5},{1:[3]},{5:16,7:5,8:6,9:7,10:8,11:9,12:10,13:$V0,15:$V1,18:$V2,23:$V3,28:$V4,66:$V6},{6:[1,18],7:19,8:6,9:7,10:8,11:9,12:10,13:$V0,15:$V1,18:$V2,23:$V3,28:$V4},o($V7,[2,78]),o($V8,[2,4]),o($V8,[2,5]),o($V8,[2,6]),o($V8,[2,7]),o($V8,[2,8]),o($V8,[2,9]),{14:20,65:$V9},{16:[1,22]},{15:[1,23]},{15:[1,24],19:[1,25]},{15:[1,26]},{6:[1,27],7:19,8:6,9:7,10:8,11:9,12:10,13:$V0,15:$V1,18:$V2,23:$V3,28:$V4},o($V7,[2,77]),{1:[2,2]},o($V8,[2,3]),{4:28,66:$V5},o($Va,[2,76]),{15:$Vb,17:29,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,56:30,58:31,62:33,64:34},{19:[1,40]},{19:[1,41]},{24:42,34:43,35:$Vf},{25:[1,45]},{1:[2,1]},o($V8,[2,10],{66:$V6}),{4:46,66:$V5},o($Va,[2,60],{57:[1,47],59:[1,48],60:[1,49],61:[1,50]}),o($Vg,[2,65],{42:$Vh,50:$Vi}),{15:$Vb,19:$Vc,51:36,52:$Ve,54:35,62:53,64:34},o($Vj,[2,69],{40:$Vk,63:$Vl}),o($Vm,[2,72]),o($Vm,[2,73]),o($Vm,[2,74]),{15:$Vb,17:56,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,56:30,58:31,62:33,64:34},o($Vm,[2,57]),o($Vm,[2,49]),{15:[1,58],20:57},{24:59,34:43,35:$Vf},{21:[1,60],33:$Vn},o($Vo,[2,26]),{16:[1,62]},{4:63,66:$V5},o($V8,[2,11],{66:$V6}),{15:$Vb,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,58:64,62:33,64:34},{15:$Vb,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,58:65,62:33,64:34},{15:$Vb,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,58:66,62:33,64:34},{15:$Vb,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,58:67,62:33,64:34},{15:$Vb,19:$Vc,51:36,52:$Ve,54:35,62:68,64:34},{15:$Vb,19:$Vc,51:36,52:$Ve,54:35,62:69,64:34},o($Vj,[2,68],{40:$Vk,63:$Vl}),{15:$Vb,19:$Vc,51:36,52:$Ve,54:35,64:70},{15:$Vb,19:$Vc,51:36,52:$Ve,54:35,64:71},{21:[1,72]},{21:[1,73],33:[1,74]},o($Vo,[2,24]),{21:[1,75],33:$Vn},{22:76,25:$Vp},{34:78,35:$Vf},{14:81,15:$Vb,17:80,19:$Vc,36:79,42:$Vd,51:36,52:$Ve,54:35,56:30,58:31,62:33,64:34,65:$V9},{29:82,34:83,35:$Vf,66:$V6},o($Vg,[2,61],{42:$Vh,50:$Vi}),o($Vg,[2,62],{42:$Vh,50:$Vi}),o($Vg,[2,63],{42:$Vh,50:$Vi}),o($Vg,[2,64],{42:$Vh,50:$Vi}),o($Vj,[2,66],{40:$Vk,63:$Vl}),o($Vj,[2,67],{40:$Vk,63:$Vl}),o($Vm,[2,70]),o($Vm,[2,71]),o($Vm,$Vq),{22:84,25:$Vp},{15:[1,85]},{22:86,25:$Vp},{4:87,66:$V5},{4:88,66:$V5},o($Vo,[2,25]),o($Va,[2,29]),o($Va,[2,55]),o($Va,[2,56]),{26:[1,89],34:90,35:$Vf},{4:91,66:$V5},{4:92,66:$V5},o($Vo,[2,23]),{4:93,66:$V5},o($V8,[2,14],{66:$V6}),{15:$Vr,26:[1,94],27:95,30:96,31:97,32:98,66:$V6},{4:100,66:$V5},{4:101,66:$V5},o($Vs,[2,28],{66:$V6}),o($V8,[2,12],{66:$V6}),o($V8,[2,13],{66:$V6}),{66:[2,15]},{15:$Vr,26:[1,102],30:103,31:97,32:98},o($Vt,[2,19]),{4:104,66:$V5},{4:106,15:[1,107],31:105,66:$V5},{14:112,15:$Vb,17:111,19:$Vu,37:120,38:$Vv,39:115,41:119,42:$Vw,43:108,44:110,45:[1,109],49:114,51:36,52:$Ve,53:113,54:35,55:$Vx,56:30,58:31,62:33,64:34,65:$V9,66:$Vy},o($V8,[2,17],{66:$V6}),o($Vs,[2,27],{66:$V6}),{66:[2,16]},o($Vt,[2,18]),o($Vt,[2,20],{66:$V6}),{4:122,66:$V5},o($Vt,[2,22],{66:$V6}),{14:112,15:$Vb,17:111,19:$Vu,37:120,38:$Vv,39:115,41:119,42:$Vw,43:108,44:110,49:114,51:36,52:$Ve,53:113,54:35,55:$Vx,56:30,58:31,62:33,64:34,65:$V9,66:$Vy},{33:[1,123],66:[2,35]},o([15,66],[2,39]),o($Vz,[2,38]),o($Vz,[2,50]),o($Vz,[2,51]),o($Vz,[2,52]),o($Vz,[2,53]),o($Vz,[2,54],{40:[1,124]}),{14:126,15:$Vb,17:125,19:$Vc,42:$Vd,51:36,52:$Ve,54:35,56:30,58:31,62:33,64:34,65:$V9},{15:$Vb,17:128,19:$Vc,37:127,38:$Vv,42:$Vd,51:36,52:$Ve,54:35,56:30,58:31,62:33,64:34},{15:$Vb,19:[1,129],51:36,52:$Ve,54:35,62:53,64:34},o($VA,[2,32]),o($VA,[2,34],{42:[1,130]}),o([21,33,40,42,47,48,66],[2,30]),o($Vt,[2,21],{66:$V6}),{14:112,15:$Vb,17:111,19:$Vu,37:120,38:$Vv,39:115,41:119,42:$Vw,44:131,49:114,51:36,52:$Ve,53:113,54:35,55:$Vx,56:30,58:31,62:33,64:34,65:$V9},{37:120,38:$Vv,41:132},o($Vz,[2,58]),o($Vz,[2,59]),{21:[1,133],33:[1,134]},{21:[1,135],33:[1,136]},{15:$Vb,17:56,19:$Vc,37:137,38:$Vv,42:$Vd,51:36,52:$Ve,54:35,56:30,58:31,62:33,64:34},{37:138,38:$Vv},o($Vz,[2,37]),o($VA,[2,31]),o($Vz,[2,42],{50:[1,139]}),{37:140,38:$Vv},o([33,40,42,50,57,59,60,61,63,66],$Vq,{46:141,47:$VB,48:$VC}),{37:144,38:$Vv},{21:[1,145]},o($VA,[2,33]),o($Vz,[2,45]),{46:146,47:$VB,48:$VC},o($Vz,[2,43]),o($Va,[2,40]),o($Va,[2,41]),{21:[1,147],33:[1,148]},o($Vz,[2,44]),{21:[1,149]},o($Vz,[2,46]),{37:150,38:$Vv},o($Vz,[2,48]),{46:151,47:$VB,48:$VC},{21:[1,152]},o($Vz,[2,47])];
    defaultActions: {[key:number]: any} = {18:[2,2],27:[2,1],94:[2,15],102:[2,16]};

    performAction (yytext:string, yyleng:number, yylineno:number, yy:any, yystate:number /* action[1] */, $$:any /* vstack */, _$:any /* lstack */): any {
/* this == yyval */
          var $0 = $$.length - 1;
        switch (yystate) {
case 1: case 2:
 return { type: NodeType.Unit, path: yy.path, code: $$[$0-1] }; 
break;
case 3:
 this.$ = $$[$0-1].concat([$$[$0]]); 
break;
case 4: case 24: case 26:
 this.$ = [$$[$0]]; 
break;
case 10:
 this.$ = { type: NodeType.Include, path: yy.path, file: $$[$0-1] }; 
break;
case 11:
 this.$ = { type: NodeType.Assignment, name: $$[$0-3], value: $$[$0-1] } as ASTAssignmentNode; 
break;
case 12:
 this.$ = { type: NodeType.Macro, path: yy.path, name: $$[$0-5], arguments: $$[$0-3], code: $$[$0-1] } as ASTMacroNode; 
break;
case 13:
 this.$ = { type: NodeType.Block, path: yy.path, name: $$[$0-5], properties: $$[$0-3], code: $$[$0-1] }; 
break;
case 14:
 this.$ = { type: NodeType.Block, path: yy.path, name: '*anonymous', properties: $$[$0-3], code: $$[$0-1] }; 
break;
case 15:
 this.$ = []; 
break;
case 16: case 75:
 this.$ = $$[$0-1]; 
break;
case 17:
 this.$ = { type: NodeType.Bank, path: yy.path, name: $$[$0-5], properties: $$[$0-2] }; 
break;
case 18:
 this.$ = $$[$0-1].concat($$[$0]); 
break;
case 20:
 this.$ = [{ type: NodeType.Statement, instruction: $$[$0-1] }]; 
break;
case 21:
 this.$ = [$$[$0-2], $$[$0-1]]; 
break;
case 22:
 this.$ = [$$[$0-1]] 
break;
case 23: case 25: case 37:
 this.$ = $$[$0-2].concat([$$[$0]]); 
break;
case 27:
 this.$ = $$[$0-2].concat([$$[$0-1]]); 
break;
case 28:
 this.$ = [$$[$0-1]]; 
break;
case 29:
 this.$ = { type: NodeType.Property, path: yy.path, name: $$[$0-2].substr(1), value: $$[$0] }; 
break;
case 30: case 57:
 this.$ = { type: NodeType.Identifier, path: yy.path, identifier: $$[$0] } as ASTIdentifierNode; 
break;
case 31:
 this.$ = {...$$[$0-2], registers: [...$$[$0-2].registers, $$[$0]] }; 
break;
case 32:
 this.$ = { type: NodeType.RegisterList, path: yy.path, registers: [$$[$0]] }; 
break;
case 33:
 this.$ = { type: NodeType.RegisterRange, path: yy.path, start: $$[$0-2], end: $$[$0] }; 
break;
case 34:
 this.$ = $$[$0] 
break;
case 35:
 { const [_m, _s] = $$[$0-1].split('.', 2); this.$ = { type: NodeType.Instruction, path: yy.path, mnemonic: _m, size: getOperandSize(_s), arguments: $$[$0] } as ASTInstructionNode; } 
break;
case 36:
 { const [_m, _s] = $$[$0].split('.', 2); this.$ = { type: NodeType.Instruction, path: yy.path, mnemonic: _m, size: getOperandSize(_s), arguments: [] } as ASTInstructionNode; } 
break;
case 38:
 this.$ = [$$[$0]] 
break;
case 39:
 this.$ = { type: NodeType.Label, path: yy.path, name: $$[$0-1] } as ASTLabelNode; 
break;
case 40:
 this.$ = OperandSize.Word 
break;
case 41:
 this.$ = OperandSize.Long 
break;
case 42:
 this.$ = { type: NodeType.Indirect, path: yy.path, value: $$[$0-1] } as ASTIndirectNode; 
break;
case 43:
 this.$ = { type: NodeType.Absolute, size: $$[$0], path: yy.path, value: $$[$0-2] } as ASTAbsoluteNode; 
break;
case 44:
 this.$ = { type: NodeType.Indirect, path: yy.path, value: $$[$0-1], predecrement: true } as ASTIndirectNode; 
break;
case 45:
 this.$ = { type: NodeType.Indirect, path: yy.path, value: $$[$0-2], postincrement: true } as ASTIndirectNode; 
break;
case 46:
 this.$ = { type: NodeType.Indirect, path: yy.path, value: $$[$0-1], displacement: $$[$0-3] } as ASTIndirectNode; 
break;
case 47:
 this.$ = { type: NodeType.Indirect, path: yy.path, value: $$[$0-4], displacement: $$[$0-6], index: $$[$0-2], indexSize: $$[$0-1] } as ASTIndirectNode; 
break;
case 48:
 this.$ = { type: NodeType.Indirect, path: yy.path, value: $$[$0-4], displacement: { type: NodeType.Number, path: yy.path, value: 0 } as ASTNumberNode, index: $$[$0-2], indexSize: $$[$0-1] } as ASTIndirectNode; 
break;
case 49:
 this.$ = { type: NodeType.Number, path: yy.path, value: parseNumber($$[$0]) }; 
break;
case 54:
 if ($$[$0].registers.length === 1 && $$[$0].registers[0].type === NodeType.Identifier) { this.$ = $$[$0].registers[0]; } else { this.$ = $$[$0]; } 
break;
case 58: case 59:
 this.$ = { type: NodeType.Immediate, path: yy.path, value: $$[$0] } as ASTImmediateNode; 
break;
case 61:
 this.$ = { type: NodeType.LeftShift, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTLeftShiftNode; 
break;
case 62:
 this.$ = { type: NodeType.RightShift, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTRightShiftNode; 
break;
case 63:
 this.$ = { type: NodeType.BitwiseOr, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTBitwiseOrNode; 
break;
case 64:
 this.$ = { type: NodeType.BitwiseAnd, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTBitwiseAndNode; 
break;
case 66:
 this.$ = { type: NodeType.Addition, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTAdditionNode; 
break;
case 67:
 this.$ = { type: NodeType.Subtraction, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTSubtractionNode; 
break;
case 68:
 this.$ = { type: NodeType.UnaryMinus, path: yy.path, value: $$[$0] } as ASTUnaryMinusNode; 
break;
case 70:
 this.$ = { type: NodeType.Multiplication, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTMultiplicationNode; 
break;
case 71:
 this.$ = { type: NodeType.Division, path: yy.path, left: $$[$0-2], right: $$[$0] } as ASTDivisionNode; 
break;
case 76:
 this.$ = { type: NodeType.String, path: yy.path, value: parseString($$[$0]) }; 
break;
        }
    }
}


/* generated by ts-jison-lex 0.3.0 */
import { JisonLexer, JisonLexerApi } from '@ts-jison/lexer';
export class HL68kLexer extends JisonLexer implements JisonLexerApi {
    options: any = {"case-insensitive":true,"moduleName":"HL68k"};
    constructor (yy = {}) {
        super(yy);
    }

    rules: RegExp[] = [/^(?:"[^"]+")/i,/^(?:;.*\n)/i,/^(?:0b[01][01_]*\b)/i,/^(?:\$[0-9A-F][0-9A-F_]*\b)/i,/^(?:[0-9][0-9_]*\b)/i,/^(?:block\b)/i,/^(?:bank\b)/i,/^(?:include\b)/i,/^(?:macro\b)/i,/^(?:@[A-Z_.][A-Z_.0-9]+\b)/i,/^(?:\.w\b)/i,/^(?:\.l\b)/i,/^(?:(a\d|d\d|sp|sr|usp|fp|pc)\b)/i,/^(?:[A-Z_.][A-Z_.0-9]+\b)/i,/^(?:,)/i,/^(?:\()/i,/^(?:\))/i,/^(?:\[)/i,/^(?:\])/i,/^(?:\{)/i,/^(?:\})/i,/^(?:=)/i,/^(?:;)/i,/^(?:>>)/i,/^(?:<<)/i,/^(?::)/i,/^(?:\|)/i,/^(?:&)/i,/^(?:#)/i,/^(?:-)/i,/^(?:\+)/i,/^(?:\*)/i,/^(?:\/)/i,/^(?:@)/i,/^(?:<)/i,/^(?:>)/i,/^(?:\n)/i,/^(?:\s+)/i,/^(?:$)/i,/^(?:.)/i];
    conditions: any = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],"inclusive":true}}
    performAction (yy:any,yy_:any,$avoiding_name_collisions:any,YY_START:any): any {
          var YYSTATE=YY_START;
        switch($avoiding_name_collisions) {
    case 0:return 65
      break;
    case 1:return 66
      break;
    case 2:return 52
      break;
    case 3:return 52
      break;
    case 4:return 52
      break;
    case 5:return 23
      break;
    case 6:return 28
      break;
    case 7:return 13
      break;
    case 8:return 18
      break;
    case 9:return 35
      break;
    case 10:return 47
      break;
    case 11:return 48
      break;
    case 12:return 38
      break;
    case 13:return 15
      break;
    case 14:return 33
      break;
    case 15:return 19
      break;
    case 16:return 21
      break;
    case 17:return '['
      break;
    case 18:return ']'
      break;
    case 19:return 25
      break;
    case 20:return 26
      break;
    case 21:return 16
      break;
    case 22:return ';'
      break;
    case 23:return 59
      break;
    case 24:return 57
      break;
    case 25:return 45
      break;
    case 26:return 60
      break;
    case 27:return 61
      break;
    case 28:return 55
      break;
    case 29:return 42
      break;
    case 30:return 50
      break;
    case 31:return 63
      break;
    case 32:return 40
      break;
    case 33:return '@'
      break;
    case 34:return '<'
      break;
    case 35:return '>'
      break;
    case 36:return 66
      break;
    case 37:if (yy.trace) yy.trace(`Skip whitespace ${hexlify(yy_.yytext)}`)
      break;
    case 38:return 6
      break;
    case 39:return 'INVALID'
      break;
        }
    }
}

